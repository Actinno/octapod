
import psycopg2
from psycopg2 import sql
import psycopg2.extensions
from eliot.logging.configured import log
from eliot.config import config
from eliot.component.HealthStatus import HealthStatus as hs

class DataRegisterNotInitialized(Exception):
    def __init__(self):
        self.message = "BUG: el objeto DataRegister no se ha inicializado correctamente"
        super().__init__(self.message)

class DataRegister(object):
    """
    Esta clase se encarga de almacenar, local o remotamete, los 
    registros leídos de los dispositivos Modbus.

    El almacenamiento local consiste en una base de datos.
    El almacenamiento remoto consiste en el uso de un RESTful API.

    :ivar controller: Inicializado como None, debe asignarse un objeto tipo :class:`eliot.controller.ControllerDB` o :class:`eliot.controller.ControllerREST`
    :ivar records: Inicializado como None, debe asignarse un diccionario con los valores de los Holding Register leídos del dispositivo
    :ivar device: Inicializado como None, debe asignarse un objeto de alguna subclase de :class:`eliot.component.ModbusDevice`, específicamente algún driver contenido en el paquete :mod:`eliot.drivers` o alguno de sus sub-paquetes.
    :ivar timestamp: Inicializado como None, debe asignarse un objeto de tipo datetime.datetime
    """

    def __init__(self):
        self.controller = None
        self.records = None
        self.device = None
        self.timestamp = None

    def save_data(self):
        if self.controller == None or \
           self.records == None or \
           self.device == None or \
           self.timestamp == None:
            raise DataRegisterNotInitialized

        if config.minieliot.mode == "local":
            log.info(f"[{self.device.unique_id}]: Guardando registro localmente")
            self.__saveLocalRegister()
        else:
            log.info(f"[{self.device.unique_id}]: Guardando registro remotamente")
            self.__saveRemoteRegister()

    def __insert_into_table(self, table):
        SQL_INSERT_T = "INSERT INTO {table} ({fields}) VALUES ({values})"

        column_names = ["unique_id", "ts"] + list(map(str.lower, self.records.keys()))
        f = sql.SQL(',').join(map(sql.Identifier, column_names))
        v = sql.SQL(',').join(sql.Placeholder() * len(column_names))
        t = sql.Identifier(table)

        SQL_INSERT = sql.SQL(SQL_INSERT_T).format(fields=f, values=v, table=t)
        
        values = [self.device.unique_id, self.timestamp] + list(self.records.values())
        self.controller.cursor.execute(SQL_INSERT, values)
        self.controller.conn.commit()

    def __insert_into_file(self, table_name):
        date = self.timestamp.strftime("%Y-%m-%d")
        path = config.minieliot.data_dir
        filename = f"{path}/{date}-{self.device.mgw.addr}-{table_name}.log"

        values = [self.device.unique_id, self.timestamp] + list(self.records.values())
        values_str = ",".join(map(str, values)) + "\n"

        try:
            with open(filename, "a") as data_file:
                data_file.write(values_str)
                data_file.close()
            hs.set_filestatus(self.device.mgw.name, filename, "OK")
        except Exception as e:
            # TODO: Corregir captura de excepciones
            log.error(f"[{self.device.unique_id}]: Error de escritura en archivo '{filename}': {e}")
            hs.set_filestatus(self.device.mgw.name, filename, "W_ERROR: {}".format(e))
        
    def __insert_hr_record(self):
        # TODO: El nombre de la tabla debería ser configurable en lugar
        #       de tratar de deducirlo a partir del modelo del dispositivo
        table = "{}_hr".format(self.device.model.lower())
        self.__insert_into_file(table)
        self.__insert_into_table(table)

    def __saveLocalRegister(self):
        self.__insert_hr_record()

    def __saveRemoteRegister(self):
        pass

