
import threading
from eliot.config import config

class UnkownHealthParameter(Exception):
    pass

class UnkownGatewayName(Exception):
    pass

class HealthStatus(object):
    __lock = None
    __health = {}
    for gw in config.gateways:
        # El cast a dict es necesario para que se cree un objeto
        # para cada gw y no que a todos se le asigne una referencia
        # al mismo objeto
        __health[gw.name] = dict({
            'db_connection': None,
            'db_IO': None,
            'gw_connection': None,
            'gw_thread_restart_count': 0,
            'gw_IO': None,
            'file_IO': {}
        })

    @classmethod
    def set_status(cls, gw_name, key, value):
        cls.__lock = threading.Lock()
        cls.__validate_gw_name(gw_name)
        cls.__validate_key(gw_name, key)
        cls.__lock.acquire()
        cls.__health[gw_name][key] = value
        cls.__lock.release()
    
    @classmethod
    def set_filestatus(cls, gw_name, filename, value):
        cls.__lock = threading.Lock()
        cls.__validate_gw_name(gw_name)
        cls.__lock.acquire()
        cls.__health[gw_name]['file_IO'][filename] = value
        cls.__lock.release()

    @classmethod
    def get_status(cls, gw_name, key):
        cls.__validate_gw_name(gw_name)
        cls.__validate_key(gw_name, key)
        return cls.__health[gw_name][key]

    @classmethod
    def keys(cls, gw_name):
        cls.__validate_gw_name(gw_name)
        return cls.__health[gw_name].keys()

    @classmethod
    def gateways(cls):
        return cls.__health.keys()

    @classmethod
    def __validate_gw_name(cls, gw_name):
        if cls.__health.get(gw_name) is None:
            raise UnkownGatewayName(f"No existe configuraci√≥n para gateway '{gw_name}'")

    @classmethod
    def __validate_key(cls, gw_name, key):
        cls.__validate_gw_name(gw_name)
        if key not in cls.keys(gw_name):
            raise UnkownHealthParameter

