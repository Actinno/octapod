
from pymodbus.register_read_message import ReadHoldingRegistersResponse
from pymodbus.exceptions import *
from pymodbus.pdu import ExceptionResponse
from pymodbus.payload import BinaryPayloadDecoder, BinaryPayloadBuilder
from pymodbus.constants import Endian
from eliot.util.file import load_json_file
from eliot.logging.configured import log
import time

class HoldingRegisterException(Exception):
    pass

class HoldingRegisterReadError(HoldingRegisterException):
    pass

class HoldingRegisterUnknownError(HoldingRegisterException):
    pass

class HoldingRegister(object):
    def __init__(self, device, hr_name, hr_addr, hr_size, hr_type, hr_trans):
        self.__device = device
        self.name = hr_name
        self.addr = hr_addr
        self.size = hr_size
        self.type = hr_type
        self.decoder = self.__get_decoder(self.type)
        self.__translated_values = hr_trans
        self.__read_value = None
        self.__decoded_value = None
        self.__tanslated_value = None

    def __str__(self):
        if self.__device is not None:
            self.read()
            self.decode()
            self.translate()
            return str(self.__tanslated_value)
        else:
            raise RuntimeError(f"Todavía no se especifica el dispositivo para el holding register {self.name}")

    def __get_conn(self):
        return self.__device.gw_conn()

    def write(self, data):
        c = self.__get_conn()
        c.write_register(self.addr, data, unit=self.__device.addr)

    def __raise_response_error(self, r):
        if isinstance(r, ModbusIOException):
            raise HoldingRegisterReadError(f"[{self.__device.unique_id}]: ModbusIOException: {r}")
        elif isinstance(r, ParameterException):
            raise HoldingRegisterReadError(f"[{self.__device.unique_id}]: ParameterException: {r}")
        elif isinstance(r, NotImplementedException):
            raise HoldingRegisterReadError(f"[{self.__device.unique_id}]: NotImplementedException: {r}")
        elif isinstance(r, ConnectionException):
            raise HoldingRegisterReadError(f"[{self.__device.unique_id}]: ConnectionException: {r}")
        elif isinstance(r, NoSuchSlaveException):
            raise HoldingRegisterReadError(f"[{self.__device.unique_id}]: NoSuchSlaveException: {r}")
        elif isinstance(r, InvalidMessageReceivedException):
            raise HoldingRegisterReadError(f"[{self.__device.unique_id}]: InvalidMessageReceivedException: {r}")
        elif isinstance(r, MessageRegisterException):
            raise HoldingRegisterReadError(f"[{self.__device.unique_id}]: MessageRegisterException: {r}")
        elif isinstance(r, TimeOutException):
            raise HoldingRegisterReadError(f"[{self.__device.unique_id}]: TimeOutException: {r}")
        elif isinstance(r, ExceptionResponse):
            # Exception Response(131, 3, GatewayNoResponse) -> debería volver a intentar?
            log.debug(f"[{self.__device.unique_id}]: r.check: {r.check}")
            log.debug(f"[{self.__device.unique_id}]: r.exception_code: {r.exception_code}")
            log.debug(f"[{self.__device.unique_id}]: r.function_code: {r.function_code}")
            log.debug(f"[{self.__device.unique_id}]: r.original_code: {r.original_code}")
            log.debug(f"[{self.__device.unique_id}]: r.protocol_id: {r.protocol_id}")
            log.debug(f"[{self.__device.unique_id}]: r.should_respond: {r.should_respond}")
            log.debug(f"[{self.__device.unique_id}]: r.skip_encode: {r.skip_encode}")
            log.debug(f"[{self.__device.unique_id}]: r.transaction_id: {r.transaction_id}")
            log.debug(f"[{self.__device.unique_id}]: r.unit_id: {r.unit_id}")
            if r.isError():
                raise HoldingRegisterReadError(f"[{self.__device.unique_id}]: Error de lectura de registro '{self.name}': {r}")
            else:
                raise HoldingRegisterUnknownError(f"[{self.__device.unique_id}]: BUG?: recibí un ExceptionResponse pero isError==False: {r}")
        else:
            raise HoldingRegisterUnknownError(f"[{self.__device.unique_id}]: BUG: recibí una respuesta tipo: {type(r)} -> {r}")

    def read(self):
        total_reads = 3
        reads_counter = 0
        log.debug(f"[{self.__device.unique_id}]: Leyendo holding register {self.addr} de dispositivo modbus '{self.__device.description}'")

        while reads_counter < total_reads:
            reads_counter += 1

            c = self.__get_conn()
            if not c.is_socket_open():
                self.__device.mgw.connect()
                c = self.__get_conn()

            r = c.read_holding_registers(self.addr, self.size, unit=self.__device.addr)
            log.debug(f"[{self.__device.unique_id}]: read_holding_registers retornó: {r} -> {type(r)}")

            if isinstance(r, ReadHoldingRegistersResponse):
                self.__read_value = r
                self.__decoded_value = None
                self.__tanslated_value = None
                return self.__read_value
            else:
                log.info(f"[{self.__device.unique_id}]: Falló lectura de holding register {self.name}")
                if reads_counter == total_reads:
                    log.info(f"[{self.__device.unique_id}]: Abortando luego de {total_reads} intentos")
                    self.__read_value = None
                    self.__raise_response_error(r)
                else:
                    log.info(f"[{self.__device.unique_id}]: Reconectando a gateway ({reads_counter}/{total_reads})")
                    time.sleep(0.1)
                    self.__device.mgw.connect()
        log.info(f"[{self.__device.unique_id}]: NO DEBERIA ESTAR ACA")

    def decode(self):
        if self.__read_value is not None and isinstance(self.__read_value, ReadHoldingRegistersResponse):
            payloadDecoder = BinaryPayloadDecoder.fromRegisters(self.__read_value.registers, Endian.Big)
            self.__decoded_value = self.decoder(payloadDecoder)
            return self.__decoded_value
        else:
            raise RuntimeError(f"[{self.__device.unique_id}]: Debe leer el holding register antes de intentar decodificarlo")

    def read_and_decode(self):
        self.read()
        self.decode()
        return self.__decoded_value

    def translate(self):
        self.__tanslated_value = translate_value(self, self.__decoded_value)

    def translate_value(self, value):
        if value is not None:
            values_dict_len = len(self.__translated_values)
            if values_dict_len > 0:
                # self.__translated_values es un objeto tipo list(). El valor de value
                # debe corresponder a alguno de los índices de la lista.
                if value >= 0 and value < values_dict_len:
                    tanslated_value = self.__translated_values[value]
                else:
                    error_msg  = f"[{self.__device.unique_id}]: El valor {value} no está registrado en la lista"
                    error_msg += f" de valores válidos para el holding register {self.name}"
                    RuntimeError(error_msg)
            else:
                # No existe una lista de valores a traducir, devuelvo el valor original
                tanslated_value = value
            return tanslated_value
        else:
            raise RuntimeError(f"[{self.__device.unique_id}]: Debe decodificar el valor leido antes de intentar traducirlo")

    def __get_decoder(self, data_type):
        hr_decoders = {
            'int_8':    self.__decode_8bit_int,
            'uint_8':   self.__decode_8bit_uint,
            'int_16':   self.__decode_16bit_int,
            'uint_16':  self.__decode_16bit_uint,
            'int_32':   self.__decode_32bit_int,
            'uint_32':  self.__decode_32bit_uint,
            'float_32': self.__decode_32bit_float,
            'float':    self.__decode_32bit_float,
            'int_64':   self.__decode_64bit_int,
            'uint_64':  self.__decode_64bit_uint,
            'float_64': self.__decode_64bit_float,
        }
        decoder = hr_decoders.get(data_type)
        if decoder is None:
            raise RuntimeError(f"[{self.__device.unique_id}]: El tipo de dato '{data_type}' no tiene un decoder registrado")
        else:
            return decoder

    def __decode_8bit_int(self, decoder):
        r = decoder.decode_8bit_int()
        return r

    def __decode_8bit_uint(self, decoder):
        r = decoder.decode_8bit_uint()
        return r

    def __decode_16bit_int(self, decoder):
        r = decoder.decode_16bit_int()
        return r

    def __decode_16bit_uint(self, decoder):
        r = decoder.decode_16bit_uint()
        return r

    def __decode_32bit_float(self, decoder):
        r = decoder.decode_32bit_float()
        return r

    def __decode_32bit_int(self, decoder):
        r = decoder.decode_32bit_int()
        return r

    def __decode_32bit_uint(self, decoder):
        r = decoder.decode_32bit_uint()
        return r

    def __decode_64bit_float(self, decoder):
        r = decoder.decode_64bit_float()
        return r

    def __decode_64bit_int(self, decoder):
        r = decoder.decode_64bit_int()
        return r

    def __decode_64bit_uint(self, decoder):
        r = decoder.decode_64bit_uint()
        return r

