
import time
import eliot
from eliot.component.ModbusDeviceHoldingRegister import HoldingRegister, HoldingRegisterException
from pymodbus.exceptions import ModbusException, ConnectionException
from pymodbus.payload import BinaryPayloadDecoder, BinaryPayloadBuilder
from pymodbus.constants import Endian
from eliot.logging.configured import log

class HoldingRegisterBlockReadError(Exception):
    pass

class ModbusDevice(object):
    """
    Identifica a un dispositivo Modbus conectado a un gateway.
    Corresponde a una clase base que debe ser extendida para construir
    drivers.

    Los drivers son usados por la clase :class:`eliot.component.ModbusGateway`.

    :ivar unique_id: Inicializado con el valor de unique_id
    :ivar addr: Inicializado con el valor de addr
    :ivar model: Inicializado con el valor de model
    :ivar mgw: Inicializado con el valor de mgw
    :ivar hr_readings: Inicializado con el valor de hr_readings, corresponde a la lista de atributos que se configuró para leer del dispositivo
    :ivar holding_registers: Inicializado como un diccionario vacío, poblado por el método :func:`ModbusDevice.add_holding_register`
    """

    def __init__(self, mgw, device_cfg):
        self.mgw                = mgw
        self.unique_id          = device_cfg.unique_id
        self.addr               = device_cfg.modbus_addr
        self.model              = device_cfg.model
        self.description        = device_cfg.description
        self.hr_readings        = device_cfg.hr_readings
        self.holding_registers = dict()
        self.holding_registers_by_addr = dict()

        if not isinstance(self.addr, int):
            raise TypeError("'addr' tiene que ser un número entero.")

        #if not isinstance(self.unique_id, long):
        #    raise TypeError("'unique_id' tiene que ser un número entero.")

        if not isinstance(self.mgw, eliot.component.ModbusGateway.ModbusGateway):
            raise TypeError("'mgw' tiene que ser un objeto de clase ModbusGateway.")

    def gw_conn(self):
        """
        Entrega una referencia al objeto de conexión de ModbusTcpClient del gateway
        en el cual está registrado este dispositivo.

        :rtype: ModbusTcpClient
        """

        return self.mgw.gw_conn()

    def add_holding_register(self, device, hr_name, hr_addr, hr_size, hr_type, hr_trans):
        """
        Agrega un Holding Register de clase :class:`eliot.component.ModbusDeviceHoldingRegister.HoldingRegister`
        al dispositivo.

        El Holding Register es agregado al inventario holding_registers y, además,
        es registrado como atributo del objeto.
        """

        hr_args = (device, hr_name, hr_addr, hr_size, hr_type, hr_trans)
        hr = HoldingRegister(*hr_args)

        self.holding_registers[hr_name] = hr
        self.holding_registers_by_addr[hr_addr] = hr
        setattr(device, hr_name, hr)

    def read_all_holding_registers(self):
        r = self.read_holding_registers(["ALL"])
        return r
       
    def read_holding_registers(self, hr_readings):
        """
        Método para leer todos los holding registers del dispositivo, decodificarlos y
        traducirlos (para los que tengan un diccionario de equivalencias).

        :rtype: dict
        """

        if len(hr_readings) == 1 and hr_readings[0] == "ALL":
            hr_read_list = list(self.holding_registers.keys())
        else:
            hr_read_list = hr_readings

        log.info(f"[{self.unique_id}]: Leyendo registros de dispositivo: {self.description} -> {self.model}")
        t0 = time.time()
        record = {}
        for hr in self.holding_registers.values():
            if hr.name in hr_read_list:
                try:
                    r = hr.read()
                    d = hr.decode()
                    t = hr.translate()
                    log.debug(f"[{self.unique_id}]: readed registers: {r.registers}, decoded value: {d}, translated value: {t}")
                    record[hr.name] = t
                except (ConnectionException, HoldingRegisterException) as e:
                    log.error(f"[{self.unique_id}]: Error de lectura de dispositivo '{self.description}': {e}")
                    record = {}
                    break
                except ModbusException as e:
                    log.error(f"[{self.unique_id}]: Error de conexión a {self.gw_conn().host}: {e}")
                    record = {}
                    break
            else:
                record[hr.name] = None
        t1 = time.time() - t0
        log.info(f"[{self.unique_id}]: Tiempo de lectura para dispositivo {self.description}: {t1} segundos")

        return record

    def block_read_decode_all(self):
        if not hasattr(self, "addresses_blocks"):
            raise NotImplemented("La lista de bloques debe estar definida en el driver del dispositivo")

        record = dict()
        t0 = time.time()
        try:
            for block in self.addresses_blocks.keys():
                log.info(f"[{self.unique_id}]: Leyendo registros de bloque {block}")
                r  = self.block_reader(block)
                rr = self.block_decoder(block, r.registers)
                record.update(rr)
            t1 = time.time() - t0
            log.info(f"[{self.unique_id}]: Tiempo de lectura para dispositivo {self.description}: {t1} segundos")
        except HoldingRegisterBlockReadError as e:
            log.error(f"[{self.unique_id}]: Error de lectura de dispositivo '{self.description}': {e}")
        return record

    def block_reader(self, block):
        if not hasattr(self, "addresses_blocks"):
            raise NotImplemented("La lista de bloques debe estar definida en el driver del dispositivo")

        if self.addresses_blocks.get(block) == None:
            raise RuntimeError(f"[{self.unique_id}]: El bloque {block} no está definido en el driver.")

        start_addr = self.addresses_blocks[block]["start_addr"]
        word_count = self.addresses_blocks[block]["word_count"]
        total_reads = 3
        reads_counter = 0

        while reads_counter < total_reads:
            reads_counter += 1

            c = self.gw_conn()
            if not c.is_socket_open():
                self.mgw.connect()
                c = self.gw_conn()

            r = c.read_holding_registers(start_addr, word_count, unit=self.addr)

            if r.isError():
                if reads_counter == total_reads:
                    raise HoldingRegisterBlockReadError(f"Error de lectura: {r}")
                else:
                    log.info(f"[{self.unique_id}]: Reconectando a gateway ({reads_counter}/{total_reads})")
                    time.sleep(0.1)
            else:
                return r

    def block_decoder(self, block, registers):
        result = dict()

        start_addr = self.addresses_blocks[block]["start_addr"]
        end_addr = self.addresses_blocks[block]["end_addr"]

        pd = BinaryPayloadDecoder.fromRegisters(registers, Endian.Big)
        a = start_addr

        while a <= end_addr:
            hr = self.holding_registers_by_addr[a]
            result[hr.name] = hr.decoder(pd)
            a += hr.size

        return result

