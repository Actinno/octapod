
import time
import sys
from eliot.logging.configured import log
from eliot.component.HealthStatus import HealthStatus as hs
import asyncio
import tornado.escape
import tornado.ioloop
import tornado.locks
import tornado.web
import uuid
from eliot.component.Task import Task
from tornado.platform.asyncio import AnyThreadEventLoopPolicy

class ControllerHealth(Task):
    def __init__(self, **kwargs):
        super().__init__()
        self._health = hs
        self._port = kwargs.get("port") or 8888
        self._debug = kwargs.get("debug") or False
        self.name = "health_controller"
        self.count = 0
        self.__tornadoIOloop = None

    def run(self):
        log.info("Iniciando Health thread")
        url_list = []
        controller = dict(health_controller=self)

        for gw_name in self.gateways():
            url_list.append((rf"^/health_status/({gw_name})/?$", StatusHandler, controller))
            for key in self.keys(gw_name):
                url_list.append((rf"^/health_status/({gw_name})/({key})/?$", StatusHandler, controller))
        url_list.append((r"^/$", MainHandler, controller))
        url_list.append((r"^/health_status/?$", StatusHandler, controller))
        url_list.append((r"^/.*", InvalidPathHandler))

        # TODO: averiguar qué coño hace esto
        asyncio.set_event_loop_policy(AnyThreadEventLoopPolicy())

        app = tornado.web.Application(url_list, debug=self._debug,)
        app.listen(self._port)
        self.__tornadoIOloop = tornado.ioloop.IOLoop.instance()
        self.__tornadoIOloop.start()

        # Terminando el thread cuando termine el loop de Tornado
        sys.exit()

    def stop(self):
        log.info("Deteniendo servicio HTTP de Health thread")
        self.__tornadoIOloop.add_callback(self.__tornadoIOloop.stop)
        log.info("Servicio HTTP detenido, terminando thread")

    #def set_status(self, key, value):
    #    self._health.set_status(key, value)

    def get_status(self, gw_name, key):
        return self._health.get_status(gw_name, key)
    
    def gateways(self):
        return self._health.gateways()

    def keys(self, gw_name):
        return self._health.keys(gw_name)

class MainHandler(tornado.web.RequestHandler):
    def initialize(self, health_controller):
        self.health_controller = health_controller

    def get(self):
        response = {}
        response["method"] = "GET"
        response["path"] = ["/health_status"]

        for gw_name in self.health_controller.gateways():
            response["path"].append(f"/health_status/{gw_name}")
            for key in self.health_controller.keys(gw_name):
                response["path"].append(f"/health_status/{gw_name}/{key}")

        self.write(response)

class StatusHandler(tornado.web.RequestHandler):
    def initialize(self, health_controller):
        self.health_controller = health_controller

    def get(self, gw_name=None, key=None):
        status = {}
        response = {}

        if gw_name == None:
            gw_list = self.health_controller.gateways()
        else:
            gw_list = [gw_name]

        for gw_name in gw_list:
            status[gw_name] = dict()
            if key == None:
                for key in self.health_controller.keys(gw_name):
                    status[gw_name][key] = self.__get_status(gw_name, key)
            else:
                status[gw_name][key] = self.__get_status(gw_name, key)

        response["timestamp"] = time.time()
        response["status"] = status
        self.write(response)

    def __get_status(self, gw_name, key):
        log.info(f"Obteniendo status de parametro {key} de gateway {gw_name}")
        return self.health_controller.get_status(str(gw_name), str(key))


class InvalidPathHandler(tornado.web.RequestHandler):
    def get(self):
        response = {}
        response["timestamp"] = time.time()
        response["error"] = "Invalid request"
        self.write(response)

