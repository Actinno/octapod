
from datetime import datetime
import time
import sys
import psycopg2
from pymodbus.client.sync import ModbusTcpClient as ModbusClient
from eliot.logging.configured import log
from eliot.config import config
from eliot.controller.ControllerDB import ControllerDB
from eliot.controller.ControllerREST import ControllerREST
from eliot.component.ModbusGateway import ModbusGateway
from eliot.component.DataRegister import DataRegister, DataRegisterNotInitialized
from eliot.component.HealthStatus import HealthStatus as hs
from eliot.component.Task import Task

class ControllerMG(Task):
    """
    Clase que controla la conexión contra un gateway Modbus, la consulta de Holding Registers
    de los dispositivos Modbus conectados al gateway y, finalmente, guardar los datos leídos
    en una base de datos o un servicio REST.

    ControllerMG es una subclase de :class:`eliot.component.Task` y es configurada, controlada
    y ejecutada por los respectivos métodos de la clase :class:`eliot.controller.ControllerThread`

    """

    def __init__(self, gw):
        super().__init__()
        self.__gw_config = gw
        self.mgw = ModbusGateway(gw.name, gw.addr, gw.port)
        self.name = f"gw_controller_{gw.name}" # ControllerThread usa este atributo
        self.count = 0
        self.gw_name = gw.name
        self.dr = None

    def __add_all_slave_devices(self):
        # Si el thread falla por alguna razón, el thread controller volverá
        # a ejecutar la función run(), pero sin volver a inicializar el objeto.
        # Es importante que antes de agregar los dispositivos limpiemos todo.
        self.mgw.clear_devices()

        log.info(f"Registrando dispositivos en gateway {self.mgw.addr}")
        for device in self.__gw_config.devices:
            if device.enable:
                self.mgw.add_device(device)
            else:
                log.info(f"Ignorando dispositivo {device.description} - DESHABILITADO")

    def __wait_and_run(self):
        wait_seconds = 60 - datetime.now().second
        log.info(f"Sincronizando tiempo, durmiendo {wait_seconds} segundos")
        for i in range(wait_seconds):
            if not self.stopSignalRecv:
                time.sleep(1)
            else:
                log.info(f"Recibida señal de stop, abortando espera")
                return False
        return True

    def run(self):
        """
        Registra los dispositivos Modbus asociados al gateway y en forma periódica
        lee todos sus Holding Registers.

        Una vez que lee los datos los almacena en una base de datos o los envía a 
        un servicio REST.

        Se mantiene en ejecución hasta que reciba la señal de parar.
        """

        if self.mgw is None:
            raise RuntimeError("Se intentó iniciar el controlador de Modbus Gateway sin especificar el objeto")

        self.stopSignalRecv = False
        self.__add_all_slave_devices()

        self.dr = DataRegister()

        try:
            log.info(f"Modo de operación de miniEliot: {config.minieliot.mode}")
            if config.minieliot.mode == "local":
                self.dr.controller = ControllerDB(config=config.db_config, gw_name=self.mgw.name)
            else:
                self.dr.controller = ControllerREST(config=config.rest_config, gw_name=self.mgw.name)

            read_on_listed_minutes = [ x for x in range(0, 60, config.minieliot.read_frequency) ]
            current_device = None
            # Duerme los segundos que falten para llegar al siguiente minuto
            # y luego continúa con la ejecución
            while self.__wait_and_run():
                self.dr.timestamp = datetime.now()
                log.info(f"Procesando minuto: {self.dr.timestamp.minute}")
                if self.dr.timestamp.minute in read_on_listed_minutes:
                    log.info("Intentando conectar al ModBus Gateway")
                    self.mgw.connect()
                    log.debug("Intentando conectar a data register controller")
                    self.dr.controller.connect()
                    log.debug(f"Iniciando lectura de dispositivos: {self.mgw.devices}")
                    for self.dr.device in self.mgw.devices:
                        current_device = self.dr.device
                        log.debug(f"[{current_device.unique_id}]: Intentando lectura de dispositivo: {self.dr.device}")
                        #self.dr.records = self.dr.device.read_holding_registers(self.dr.device.hr_readings)
                        self.dr.records = self.dr.device.block_read_decode_all()
                        #log.debug(f"[{current_device.unique_id}]: lectura de dispositivo {self.dr.device}: {self.dr.records}")
    
                        if self.dr.records != {}:
                            try:
                                log.debug(f"[{current_device.unique_id}]: Intentando grabar los datos")
                                self.dr.save_data()
                                hs.set_status(self.mgw.name, 'db_IO', "OK")
                            except psycopg2.Error as e:
                                errorMsg = "Error grabando datos en DB: {}".format(e)
                                hs.set_status(self.mgw.name, 'db_IO', errorMsg)
                                log.error(errorMsg)
                        else:
                            log.info(f"[{current_device.unique_id}]: No obtuve datos para guardar")
                    log.debug("Cerrando conexión con controlador de Data Register")
                    self.dr.controller.close()
                    log.info("Cerrando conexión con Gateway ModBus")
                    self.mgw.close()
        except psycopg2.OperationalError as e:
            log.error(f"Error de comunicacion con DB: {e}")
        except Exception as e:
            log.error(f"[{current_device.unique_id}]: ERROR: recibí una excepción tipo '{type(e)}': {e}")
        finally:
            # Terminando thread y cerrando conexiones
            self.__clear_state()
            sys.exit()

    def stop(self):
        """
        Detiene el loop principal de :func:`ControllerMG.run`
        """

        log.info(f"Deteniendo thread de ControllerMG para gateway {self.mgw.addr}")
        self.stopSignalRecv = True

    def __clear_state(self):
        log.info("Limpiando estado de thread")
        if self.mgw is not None:
            self.mgw.close()
            self.mgw.clear_devices()
        if self.dr is not None:
            if self.dr.controller is not None:
                self.dr.controller.close()
            self.dr = None


