
import time
import threading
from threading import Thread
from eliot.logging.configured import log
from eliot.component.Task import Task
from eliot.controller.ControllerMG import ControllerMG
from eliot.component.HealthStatus import HealthStatus as hs

class ControllerThread(object):
    """
    Controlador de threads de :class:`eliot.MiniEliot`.
    Inicia tareas que sean subclases de :class:`eliot.component.Task`.

    Entrega métodos para configurar tareas, iniciarlas, detenerlas y
    un loop de control para verificar que se mantengan en ejecución
    hasta que se indique que deben detenerse.
    """

    def __init__(self):
        self.__tasks = []
        self.__configured = False
        self.__stopThreads = False

    def __check_configured(self):
        if not self.__configured:
            raise RuntimeError("Object not initialized")

    def setup_tasks(self, task_list):
        """
        Cofingura la lista de tareas, subclases de :class:`eliot.component.Task`.

        :param task_list: list[:class:`eliot.component.Task`]
        """

        log.info("Configurando tareas")
        if isinstance(task_list, list) and len(task_list) > 0:
            for t in task_list:
                if not isinstance(t, Task):
                    raise RuntimeError("Objeto de tipo inválido en lista de tareas: {}".format(type(t)))
                self.__tasks.append(t)
            self.__configured = True

    def start_tasks(self):
        """
        Inicia las tareas configuradas
        """

        log.info("Iniciando threads")
        self.__check_configured()
        for t in self.__tasks:
            log.info(f"Iniciando thread para tarea '{t.name}'")
            t.start_new_thread()

    def stop_tasks(self):
        """
        Detiene las tareas configuradas. Luego hay que invocar a :func:`ControllerThread.join`
        """

        log.info("Deteniendo threads")
        self.__stopThreads = True
        for t in self.__tasks:
            log.info(f"Deteniendo thread para tarea '{t.name}'")
            t.stop()

    def control_loop(self):
        """
        Verifica el estado de las tareas configuradas. Las reinicia si detecta que fallan.
        """

        log.info("Controlando y reviviendo threads")
        self.__check_configured()
        while threading.active_count() > 0 and not self.__stopThreads:
            for t in self.__tasks:
                if not t.thread_is_alive():
                    t.join_thread()
                    t.count += 1
                    log.info(f"Iniciando nuevo thread para tarea '{t.name}'. Reinicio número {t.count}.")
                    t.start_new_thread()
                    if isinstance(t, ControllerMG):
                        hs.set_status(t.gw_name, 'gw_thread_restart_count', t.count)
            time.sleep(5)

    def join(self):
        """
        Espera a que terminen las tareas configuradas.
        Se debe ejecutar posterior a :func:`ControllerThread.stop_tasks`
        """

        log.info("Esperando a que terminen las tareas")
        self.__check_configured()
        for t in self.__tasks:
            t.join_thread()

